# Effective C++

Scott Meyers의 Effective C++를 정리한 글입니다. C++ 개발자를 위한 필독 도서로, 자세한하고 정확한 내용은 책(<http://www.yes24.com/Product/Goods/17525589?OzSrank=3>)을 구입해서 읽는 것이 더 좋습니다.

## Index

01. [C++를 언어들의 연합체로 바라보는 안목은 필수](ch01.md)
02. [#define을 쓰려거든 const enum inline을 떠올리자](ch02.md)
03. 낌새만 보이면 const를 들이대 보자!
04. [객체를 사용하기 전에 반드시 그 객체를 초기화하자](ch04.md)
05. [C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자](ch05.md)
06. [컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자](ch06.md)
07. [다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자](ch07.md)
08. 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
09. [객체 생성 및 소멸 과정 중에는 절대로 가상함수를 호출하지 말자](ch09.md)
10. [대입 연산자는 asterisk this의 참조자를 반환하게 하자](ch10.md)
11. [operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자](ch11.md)
12. [객체의 모든 부분을 빠짐없이 복사하자](ch12.md)
13. [자원 관리에는 객체가 그만](ch13.md)
14. [자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자](ch14.md)
15. [자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자](ch15.md)
16. [new 및 delete를 사용할 때는 형태를 반드시 맞추자](ch16.md)
17. [new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자](ch17.md)
18. [인터페이스 설계는 제대로 쓰기엔 쉽게 엉터리로 쓰기엔 어렵게 하자](ch18.md)
19. [클래스 설계는 타입 설계와 똑같이 취급하자](ch19.md)
20. [값에 의한 전달보다는 상수객체 참조자에 의한 전달방식을 택하는 편이 대개 낫다](ch20.md)
21. [함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자](ch21.md)
22. [데이터 멤버가 선언될 곳은 private 영역임을 명심하자](ch22.md)
23. [멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자](ch23.md)
24. [타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 전언하자](ch24.md)
25. 예외를 던지지 않는 swap에 대한 지원도 생각해 보자
26. [변수 정의는 늦출 수 있는 데 까지 늦추는 근성을 발휘하자](ch26.md)
27. [캐스팅은 절약 또 절약 잊지 말자](ch27.md)
28. [내부에서 사용하는 객체에 대한 핸들을 반환하는 코드는 되도록 피하자](ch28.md)
29. [예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자](ch29.md)
30. [인라인 함수는 미주알고주알 따져서 이해해 두자](ch30.md)
31. [파일 사이의 컴파일 의존성을 최대로 줄이자](ch31.md)
32. 부터 55 까지 정리 중

## Summary

### C++에 왔으면 C++의 법을 따릅시다

- C++은 *통합언어* 가 아니라 **하위언어의 연합체** 입니다.
  하위 언어에 맞는 말투를 잘 구사하는 것이 중요합니다.
- *매크로* (#define)는 유효범위를 제한할 수 없기 때문에 좋지 않습니다.
  특히 매크로함수는 원하는대로 동작하도록 작성하기 까다롭습니다.
  매크로변수는 **const, enum** 을 매크로함수는 **inline** 을 이용하세요.
- C++의 초기화 규칙은 복잡합니다. 그냥 다 **직접 초기화** 하는게 맘 편합니다.
  클래스의 멤버를 초기화할 때는 **초기화리스트** 를 꼭 사용합시다.
- 비지역 정적객체(ex. 전역객체, 특히 전역객체인 싱글톤, 클래스 안에 static키워드가 붙은 객체)는 사용하지 마세요.
  초기화 순서가 제멋대로일 수 있습니다(다른 번역단위에서 초기화순서가 미정의사항).
  비지역 정적객체는 지역 정적객체로 바꿔서 사용하세요.

### 생성자, 소멸자 및 대입 연산자

- *"기본생성자", "복사생성자", "복사대입연산자", "소멸자"* 는 **자동** 으로 생깁니다.
  자동으로 생긴 함수들이 항상 원하는대로 동작하지는 않습니다.
  원하는대로 동작하도록 직접 잘 작성하거나,
- 아얘 호출되지 못하도록 private으로 선언해서 막으세요.
- *상속될 가능성이 있는 클래스* 는 반드시 **가상소멸자** 를 가져야만 합니다.
  반대로 가능성이 없는 경우는 가상소멸자를 만들지 마세요. 이식성이 사라집니다.
- 생성자 소멸자에서는 동적바인딩이 되지 않습니다. 파생 클래스가 아직 생성아 안됐으니까요.
  따라서 *생성자, 소멸자* 에서는 **가상함수를 호출하지 마세요**
- 대입연산자(operator=)는 \*this의 참조자를 반환하는게 관례입니다.
  그렇게 해야, ```a = b = c;```와 같은 코드가 가능해 집니다.
- 대입연산자(operator=)에서는 **자기대입** 에 대한 예외처리가 필수입니다.
  자신과 상대방을 **swap** 하는 것이 보통 좋은 대책입니다.
- Derived클래스의 복사생성자, 복사대입연산자는 Base클래스의 복사생성자, 복사대입연산자를 꼭 호출해야합니다.
  안그러면 **partial copy** (일부분만 복사됨)가 발생합니다.

### 자원 관리

- 자원관리(포인터, 뮤텍스 등...)는 **자원관리객체, RAII** 를 사용하세요.
  구현하기 귀찮으면 *스마트 포인터* 를 사용하세요.
- RAII는 **복사정책** 을 잘 결정해서 구현해야 합니다.
  소유권이전, 참조카운팅 등의 방식이 있습니다.
  스마트포인터에서는 각각 *auto_ptr, shared_ptr* 로 구현되어있습니다.
- RAII는 관리하는 자원에 접근할 수 있는 ```get()```함수를 제공해주세요.
  스마트포인터에서도 ```get()```으로 구현되어 있습니다.
- ```new```는 ```delete```로 해제하고, ```new []```는 ```delete[]```로 해제해주세요.
  배열타입은 typedef로 선언하지 않는게 좋습니다. 뭘로 해제해야할지 헷갈려요.
- 함수 파라미터에서 ```foo(shared_ptr<T>(new T));```와 같이, 객체생성과 RAII에 집어넣은 동작을 같이 하지 마세요.
  *RAII에 객체를 담는 코드* 는 반드시 **별도의 한 문장** 으로 작성해야합니다.

### 설계 및 선언

- 좋은 인터페이스는 **"제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게"** 만들어야 합니다.
  사용자가 잘못 된 코드를 작성하려하면 빌드가 아얘 안되게끔 만들어어야 합니다.
  새로 작성될 인터페이스는 기존의 인터페이스와 일관성을 유지해주는게 좋습니다.
  되도록 RAII를 사용해서 사용자가 자원관리에 신경쓰지 않도록 해주세요.
- *값에 의한 전달* 보다는 **상수객체 참조자에 의한 전달** 이 좋습니다.
  단 항상 옳은 것은 아닙니다. C++은 하위언어의 연합체라는 것을 기억하세요.
- 대입연산자 정도를 제외하고는 **참조자를 반환하지 마세요**.
  대게 쓰레기값이 반환되거나, 그렇지 않더라도 캡슐화를 해칩니다.
- *멤버변수는 반드시* **private** 에 두고 인터페이스를 통해 접근하게 해야합니다.
  이래야 *내부 로직을 변경하더라도 동일한 인터페이스를 유지* 할 수 있습니다.
  protected는 절대로 보호받는 상태가 아닙니다.
  protected여도 상속만 받으면 접근할 수 있으니까요.
- 유틸리티 함수는 멤버 함수가 아니라, 비멤버 비프렌드 함수로 만듭시다.
  이는 캡슐화 정도를 높이고, 패키징 유연성을 올리며, 기능 확장성을 늘립니다.
- 어떤 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해줄 필요가 있다면(특히 this가 가리키는 객체가 변환 되어야 할 경우에), 그 함수는 비멤버이어야 합니다.

### 구현

- 변수의 정의는 최대한 늦게, **사용하기 직전** 에 해주세요.
  사용하지도 않는데 생성/소멸이 일어나면 아까우니까요.
- **C스타일 캐스팅은 하지마세요**.
  컴파일러가 도와줄 수 도 없을 뿐더러, 눈에 잘 보이지도 않습니다.
- 어떤 객체 *내부 요소에 대한 핸들을 반환하는 것은 되도록 피하세요**.
  잘못하면 무효참조핸들이 나오고, 캡슐화에 좋지도 않습니다.
- 예외 안전성 보장은 기본적인 보장, 강력한 보장, 예외금지 보장이 있습니다.
  적어도 *기본적인 보장은 해주는게 좋습니다*.
  강력한 보장은 별로 실용적이지 않아서 많이는 안씁니다.
- *inline 함수* 는 **작고 자주 호출되는** 함수에만 사용합시다.
  아무데나 막 쓰면 목적코드 크기만 커져요.
- **컴파일 의존성** 을 낮추는데는 **Pimpl 이디엄** 을 쓰세요.
  느려지지 않을까 걱정되면 배포 직전에 클래스를 합치면 됩니다.

### 상속, 그리고 객체지향

- 정리 중