# 2 : #define을 쓰려거든 const, enum, inline을 떠올리자

## 문제인식

매크로는 전처리 과정에 특정 코드를 바꿔치기하는 수법을 이용하는데, 이 때문에 아래와 같은 문제점이 있습니다.

- 컴파일러에게 매크로는 **리터럴** 일 뿐입니다. *심볼릭 테이블에 추가되지 않습니다.* 컴파일 오류가 나도 어디에서 났는지 알기 어렵습니다.
- 매크로는 #undef를 제외하면 어떤 것도 **유효범위를 제한할 수 없습니다**. 객체 지향이 제공하는 캡슐화의 혜택을 받을 수 없습니다.
- 매크로 함수는 어떤 결과를 출력할지 예측하기 어렵습니다.

## 문제해결

이 장의 핵심은 **전처리 과정의 일을 모두 컴파일 과정으로 옮기자** 입니다. 코드 실수를 컴파일러가 잡아주기 쉽기 때문이지요.

### 매크로는 상수로

매크로를 아래와 같이 바꿉니다.

```c++
//#define ASPECT_RATIO 1.234
const double ASPECT_RATIO = 1.234;
```

상수 객체는 컴파일러의 **심볼릭 테이블에 추가** 되므로, ASPECT_RATIO에 문제가 생길경우 컴파일러가 해당 위치를 알려줍니다. 반면 매크로의 경우 숫자 리터럴로 바꿔치기 되기 때문에 이런 혜택을 받을 수 없습니다. 여기에 추가로, 상수객체는 목적파일의 크기를 줄이는데도 한몫 합니다. 매크로가 여러번 사용될 경우 그 만큼 바꾸치기 되는 리터럴의 수가 증가합니다. 반면 상수객체는 하나만 존재하면 되므로 **목적파일의 크기가 작아지는 효과** 가 있습니다. 상수 객체가 매크로보다 좋은 것이 하나 더 있습니다. 상수 객체는 유효범위의 영향을 받습니다. 특정 함수나 클래스, 네임스페이스 등 그 범위를 제한하는 것이 가능하기 때문에, 객체 지향 프로그래밍이 주는 **캡슐화의 혜택** 을 모두 누릴 수 있습니다.

> 클래스 내부에 상수객체를 멤버로 둘 경우, 초기화는 cosnt 키워드의 규칙에 따라 선언과 동시에 합니다. 클래스의 생성자가 하는것이 아닙니다.

```c++
class CCC{
private:
  const double ASPECT_RATIO = 1.234;
}
```

만약, 목적파일의 크기가 작아지는 효과 를 누리기 위해 클래스의 모든 인스턴스가 하나의 사본만을 공유하도록 하고 싶다면 static 키워드를 이용합니다. 다만, 클래스의 정적 객체는 클래스 선언 밖, 즉 구현시점에 초기화 해주어야 합니다.

```c++
class CCC{
private:
  static const double ASPECT_RATIO;
}
//...
static const double CCC::ASPECT_RATIO = 1.234;
```

### 매크로는 enum으로

매크로 대신 enum을 쓰는 것도 좋습니다. enum은 **int형으로 취급** 되는 동시에, 매크로 처럼 **주소값을 얻을 수 없다** 는 장점이 있기 때문입니다. *const* 외에도 이 방식을 알아야하는 이유가 또 있는데, 다른 코드에서 많이 쓰이기 때문입니다. 갑작스럽게 나타난 enum을 보고 당황하지 않으려면요.

### 매크로 함수는 inline 함수로

아래 코드를 실행해보세요. 예상하는 결과와는 다를 것입니다.

```c++
#define MAX(a, b) f((a) > (b) ? (a) : (b))

int main() {
  int a = 5, b = 0;
  cout << MAX(++a, b) << endl;
  cout << MAX(++a, b + 10) << endl;
}
```

매크로 함수 인자에 "()"를 씌워주는 것은 그나마 양반입니다. 이미저도 하지 않는다면, 매크로 함수가 올바를 결과를 기대하기 매우 어렵습니다.
매크로 함수를 쓰기 전에 항상 **inline 함수** 를 생각하는 것이 좋습니다. *inline* 키워드는 매크로 처럼 함수의 내용을 본문에 바꿔치기하는 방식으로 동작합니다. 따라서 함수 호출의 비용도 발생하지 않습니다.

```c++
inline int MAX(int a, int b) {
  return a > b ? a : b;
}

int main() {
  int a = 5, b = 0;
  cout << MAX(++a, b) << endl;
  cout << MAX(++a, b + 10) << endl;
}
```

함수의 리턴과 파라미터의 타입을 미리 정해줘야 한다는 것이 신경쓰인다면, **inline 함수의 templete** 을 만들면 됩니다.

```c++
templete<typename T>
inline T MAX(T a, T b) {
  return a > b ? a : b;
}

int main() {
  int a = 5, b = 0;
  cout << MAX(++a, b) << endl;      //a 두 번 증가
  cout << MAX(++a, b + 10) << endl; //a 한 번 증가
}
```

inline 함수의 templete은 매크로 함수가 가지는 모든 장점을 그대로 가지면서, 항상 올바른 결과를 출력하고 "()"를 씌우는 어색함도 없고 캡슐화의 혜택을 누릴 수 있습니다.

> 물론 항상 *inline* 키워드를 쓴다고 해서 인라인 함수로 동작하는 것은 아닙니다. 하지만 **80:20** 법칙을 떠올린다면 아주 조금 빨라지기 위해 예상치 못한 결과를 만드는 함수를 쓰는것이 어리석은 일인지 알게 될 것입니다.
80:20법칙이란 "수행시간의 80%를 차지하는 코드는, 전체코드라인의 20%에 불과하다." 라는 경험적 격언입니다. 이는 성능 향상을 위해서는 "병목이 되는 20%의 코드를 수정해야 한다"라는 말과 동시에, 어차피 나머지 80%를 빠르게 해봤자 별로 빨라지지 않으니 "병목이 아닌 코드는 조금 느리더라도 안전하고 보수하기 편하게 수정해야한다"라는 말입니다. 저는 후자의 말에 더 공감이 됩니다.

## 정리

- 매크로 함수는 "inline 함수 templete"으로 바꿉시다.
