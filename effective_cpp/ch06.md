# 6 : 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

## 문제인식

때때로, 내가 만든 객체가 복사되지 않길 원하는 경우가 있습니다.
라이브러리 제작자의 입장에서 이런 상황은 어떻게 해결해야하는지 알아봅시다.

## 문제해결

내가 만든 객체가 복사되지 않길 원해서 복사 생성자와 복사 대입 연산자를 작성하지 않는 경우가 있습니다.
하지만 한목 5에서 설명했듯 컴파일러는 기대와 달리 두 함수를 자동으로 만들어 버리며, 그마저도 올바른 동작을 기대하기 어렵습니다.
라이브러리 제작자의 입장에서 두 함수들은 자동으로 생성이 되지 않던지, 올바르게 동작하던지 둘 중 하나를 선택해야만 합니다.
이번 항목에서는 전자를 알아봅니다.

방법은 간단합니다.

```c++
class AAA{
public:
  // ...
private:
  AAA(const AAA&);
  AAA& operator=(const AAA&);
}
```

복사 생성자와 복사 대입 연산자를 private 영역에 두면 됩니다.
혹시나 나도 모르게, AAA 클래스 내부에서나 friend 클래스 내부에서 두 함수를 호출할 수도 있습니다.
이를 막기 위해선 두 함수를 아얘 정의하지 않으면 됩니다.
만일 두 함수를 호출한다면 링커가 함수의 정의를 찾아 나설 것이고, 이내 링크 에러를 출력할 것입니다.

```c++
AAA& operator=(const AAA&);
```

파라미터에 이름을 적지 않은 것에도 이유가 있습니다.
함수의 시그네처는 '함수의 이름'과 '리턴타입', '파라미터의 타입'만을 고려합니다.
파라미터의 이름은 사용자가 읽기 쉽게 하기 위함일 뿐, 컴파일러는 몰라도 아무 상관 없는 값입니다.
여기서 파라미터의 이름은 어차피 사용되지도 않을 예정이기 때문에 적어주지 않았습니다.

에러가 링킹타임에 나는 것도 참 좋지만, 이왕이면 컴파일타임에 나는 것이 더 좋습니다.
위 코드를 아래와 고치면 에러를 컴파일타임으로 끌어올 수 있습니다.

```c++
class uncopyable{
private:
  uncopyable(const uncopyable&);
  uncopyable& operator=(const uncopyable&);
}

class AAA :private uncopyable{
  // ...
}
```

파생 클래스가 자동으로 만들어진 복사 생성자와 복사 대입 연산자를 호출할 경우, 반드시 기본 클래스의 두 함수를 호출하도록 되어있습니다.
이 때 기본 클래스인 uncopyable의 두 함수가 private로 선언되어 있으므로, 파생 클래스인 AAA도 해당 함수를 호출할 경우 컴파일 에러가 발생합니다.
uncopyable 클래스를 private 상속을 한 이유는 항목 39를 확인하세요.
이러한 기법은 Boost 라이브러리의 noncopyable 클래스에도 사용되고 있어 다음과 같이 작성해도 됩니다.

```c++
#include <boost\noncopyable.hpp>
class AAA :private boost::noncopyable{
  // ...
}
```

## 정리

- 컴파일러가 자동으로 함수를 만들지 않도록 하고싶다면, 해당 함수를 private 멤버로 선언만 하세요.
- uncopyable 클래스를 상속하는 것도 좋은 방법입니다.
