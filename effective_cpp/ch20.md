# 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다

## 문제인식

C++은 C의 영향을 받았기 때문에, 함수의 파라미터로 넘어가는 객체는 기본적으로 '값 복사'를 통해 전달됩니다.
객체의 복사는 복사생성자와 소멸자 총 두 번의 함수호출을 일으킵니다.
함수 호출은 이렇게 두 번으로 끝나는 것이 아니라, 해당 클래스의 멤버 변수 객체의 복사생성자와 소멸자를 연달아 호출하면서 고비용을 유발합니다.

이 뿐만이 아닙니다.
종종 기본 클래스 타입의 객체를 파라미터로 받는 경우가 있습니다.
이 때 파생 클래스 타입의 객체를 값으로 전달하면 **복사손실** 이 발생합니다.
복사손실은 파라미터가 기본 클래스 타입이기 때문에 기본 클래스의 생성자만 호출되며, 이로인해 파생 클래스의 특징들이 모두 잘려나가는 문제를 일으킵니다.

## 문제해결

함수의 파라미터로 **상수객체 참조자** 에 의한 전달을 이용합니다.

```c++
void foo(const Widget& w);
```

참조자는 컴파일러 내부에서 포인터로 바뀌기 때문에 값을 복사하는데서 발생하는 복사생성자와 소멸자의 호출이 일어나지 않습니다.
또한 포인터로 접근한 객체는 동적바인딩 되기 때문에 복사손실도 일어나지 않습니디.
상수객체로 만드는 것은, 함수 내부에서 일어나는 작용들이 외부에 영향을 미치는 부작용을 줄이기 위함입니다.

객체의 멤버가 적은 경우는 어떨까요?
만일 해당 멤버가 포인터라면 역시 상수객체 참조자에 의한 전달이 유리합니다.
포인터가 가리키는 타입과 줄줄이 엮인 다른 타입의 멤버를 모두 복사해야하기 때문입니다.
객체의 크기도 작고 줄줄이 엮인 타입도 없다면 값에 의한 전달이 좋을까요?
아닙니다.
사용자 정의 타입이라면 언제 어떻게 변할지 모릅니다.
그 크기의 변화가 항상 노출되어있다는 점을 기억하면, 역시 상수객체 참조자에 의한 전달이 유리합니다.

>기본제공 타입은 값에 의한 전달이 좋다라는 말도 있습니다`.
>아주 틀린 말은 아닙니다.
>참고로 STL의 iterator는 값으로 전달되도록 설계되어있습니다.
>C++은 하위언어의 연합체라는 것을 기억하세요.

## 정리

- 상수객체 참조자에 의한 전달이 대체적으로 효율적일 뿐만 아니라 복사손실 문제도 막아줍니다.
- 하지만 항상 옳은 것은 아닙니다. C++은 하위언어의 연합체라는 것을 기억하세요.
