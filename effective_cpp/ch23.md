# 23 : 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

## 문제인식

한 클래스의 인터페이를 연달아 호출해야할 필요가 있습니다.
예를 들면, 브라우저의 다운로드 파일이나 캐시, url 기록, 쿠키 등을 동시에 삭제하는 경우입니다.

```c++
class WebBrowser {
public:
  void clearCache();
  void clearHistory();
  void removeCookies();
  // ...
};
```

## 문제해결

이러한 기능을 동시에 제공하는 방법은 두가지가 있습니다.

- 멤버 함수

  ```c++
  void WebBrower::clearEverything() {
    clearCache();
    clearHistory();
    removeCookies();
  }
  ```

- 비멤버 비프렌드 함수

  ```c++
  void clearBrowser(){
    clearCache();
    clearHistory();
    removeCookies();
  }
  ```

다음과 같은 이유에서 **비멤버 비프렌드 함수** 가 더 좋습니다

- 캡슐화의 정도가 높아집니다.
  - 밖에서 볼 수 있는 것들이 줄어들 수록, 그것들을 바꿀 때 필요한 유연성이 커집니다.
- 패키징 유연성이 높아집니다.
- 컴파일 의존도를 낮춥니다.

주의할 점이 있습니다.

- 멤버 함수의 반대는 비멤버 프렌드 함수가 아닙니다. 비멤버 비프렌드 함수입니다.
  - 프렌드 함수는 캡슐화의 정도를 오히려 해칩니다.
- 한 클래스의 비멤버 함수라고 해서 다른 클래스의 멤버 함수가 될 수 없는 것은 아닙니다.
  - 유틸리티 클래스에 비멤버 비프렌드 함수를 모아둘 수 있습니다.
  - C++에서는 namespace를 제공합니다.

namespace는 여러 파일에 걸쳐 존재할 수 있습니다. 따라서 유틸리티 클래스로 관리하는 것 보다 컴파일 의존성을 낮추는데 더 도움이 됩니다.
이러한 유틸리티 함수의 개수가 늘어나면, 다음과 같이 유사한 유틸리티 함수를 하나의 헤더이 몰아 넣고 관리할 수 있습니다.

```c++
// webbrowser.h
namespace WebBrowserStuff {
  class WebBrowser {
    // 본체 클래스
  }
}
```

```c++
// webbrowserbookmakrs.h
namespace WebBrowserStuff {
  // 북마크 관련 유틸리티 함수들...
}
```

```c++
// webbrowsercookies.h
namespace WebBrowserStuff {
  // 쿠키 관련 유틸리티 함수들...
}
```

이로써 사용자는, 불필요한 유틸리티 함수를 자기 코드에 포함시켜 컴파일할 필요가 없어집니다.
자신이 필요한 헤더만 포함시키면 됩니다.

라이브러리 제작자는, 원하는 기능을 추가하기 위해 본체 클래스를 수정하고 다시 컴파일 할 필요가 없어집니다.
그냥 파일을 새로 만들어서 해당 네임스페이스에 원하는 함수를 추가하면 됩니다.

실제로 STL의 함수들은, 이와같은 방식으로 관련 기능들을 하나의 파일이 아닌 memory, vector, algorithm과 같은 헤더들에 나눠서 관리하고 있습니다.

## 정리

- 유틸리티 함수는 멤버 함수가 아니라, 비멤버 비프렌드 함수로 만듭시다.
- 이는 캡슐화 정도를 높이고, 패키징 유연성을 올리며, 기능 확장성을 늘립니다.
