# 4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자

## 문제인식

C++의 초기화되지 않은 객체는 기대하지 않은 동작을 유발합니다.
따라서 반드시 객체를 사용히기 전 초기화 해야하며, 그 초기화 규칙은 상황에 따라 달라 복잡합니다.
같은 타입의 객체여도 특정 상황에서는 자동으로 초기화 되는 반면, 어떤 상황에서는 초기화 되지 않습니다.

## 문제해결

Scott Meyers는 복잡한 초기화 규칙을 외우기보다는 그냥 **항상 직접 초기화는 것을 습관화** 하기를 추천합니다.

### 기본제공타입 초기화

기본제공타입은 아래와 같이 직접 손수 초기화 해줍니다.

```c++
int x = 0;

cosnt char* text = "A C-style string";

double d;
std::cin >> d;
```

### 사용자정의타입 초기화

사용자정의타입(클래스)을 초기화 하는 방법은 **생성자** 와 깊은 관계를 가지고 있습니다.
생성자를 통해 초기화하는 방법에서 항상 잊지 않아야 하는 것은, **대입을 초기화로 착각하지 않는 것** 입니다.

```c++
class BBB;

class AAA{
public:
  AAA(int a, const BBB& b);
private:
  int basicType;
  BBB userType;
}

AAA::AAA(int a, const BBB& b){
  basicType = a;
  userType = b;
}
```

위 코드를 보면 AAA 클래스의 생성자는 멤버변수들을 잘 초기화하고 있는것 처럼 보입니다.
하지만 생성자가 실제로 하는 일은 초기화가 아닌 **대입** 입니다.
int와 BBB타입의 멤버는 자신의 기본생성자로 초기화가 된 이후, 파라미터로 넘어온 a와 b가 새로 대입되고 있습니다.
기봉제공타입인 basicType의 경우 대입과 초기화가 그다지 성능차이가 나지않지만, 사용자정의타입인 userType은 상당한 차이를 만듭니다.
BBB의 기본생성자에서 값 복사가 일어난 후, b가 대입될 때 값 복사가 다시 일어나 **총 두 번의 복사가 발생** 하기 때문입니다.
올바를 초기화를 위해서는 **기본생성자** 혹은 **복사생성자** 를 이용한 초기화를 해주어야만 합니다.

```c++
class BBB;

class AAA{
public:
  AAA(int a, const BBB& b);
private:
  int basicType;
  BBB userType;
}

AAA::AAA(int a, const BBB& b) :basicType(a),  userType(b) {}
```

생성자의 모양이 좀 부자연스럽지만 이게 맞습니다.
생성자 옆에 ":"와 함께 멤버들의 복사생성자가 명시되어있습니다.
C++에서는 이것을 **초기화리스트** 라고 부르며, 초기화리스트에 적힌 생성자가 각 멤버변수의 초기화를 담당합니다.

클래스 멤버의 초기화 역시 특정 상황에서는 자동으로 초기화되고, 어떤 상황에서는 초기화 되지 않습니다.
따라서 복잡한 초기화 규칙을 외우느니 **클래스의 모든 멤버는 반드시 초기화리스트에서 초기화한다** 라는 규칙을 박아두는 것이 좋습니다.
한가지 더, 클래스의 멤버변수가 초기화 되는 순서는 선언 된 순서와 같습니다.
초기화리스트에서 순서를 뒤바꾼다고 초기화 순서가 바뀌지 않습니다.
따라서 **초기화리스트에 넣는 순서는 클래스의 변수 선언순서와 일치시킨다** 라는 규칙도 기억하면 헷갈릴 일이 없습니다.

### 정적변수 초기화

정적객체는 프로그램이 시작되는 시점에 생성되어 프로그램이 종료되는 시점에 소멸되는 객체입니다.
따라서 정적객체는 main()함수가 시작되기 전에 초기화 되어야 합니다.
정적변수의 종류는 다음과 같이 나눌 수 있는데, 그 종류에 따라 초기화 문제를 일으키는 원인이 되기도 합니다.

- 지역 정적객체
  - 함수 안에 static 키워드로 선언 된 객체
- 비지역 정적객체
  - 전역 객체
  - 네임스페이스 안에 선언 된 객체
  - 클래스 안에 static 키워드로 선언 된 객체
  - 파일 유효범위 안에서 static 키워드로 선언 된 객체 (C스타일)

문제의 원인은 **다른 번역단위의 비지역 정적객체들의 초기화 순서는 미정의사항** 이라는 것입니다.
*-번역단위는 컴파일의 결과로 하나의 목적파일을 만드는 소스코드들을 말하는데, 하나의 소스 파일과 #include를 통해 연결된 파일들의 집합을 말합니다.-*
보통, **extern** 키워드를 통해 라이브러리의 정적객체를 가저오는 경우에 문제가 발생합니다.

```c++
//내가 만든 라이브러리의 코드
extern FileSystem tfs;  //다른 번역단위에서 사용 가능한 전역객체, 즉 비지역 정적객체
//...
```

```c++
//라이브러리의 사용자의 코드
void foo{
  std::size_t disks - tfs.numDisks(); //다른 번역단위의 비지역 정적객체를 사용!
}
```

라이브러리 사용자는 자신의 코드에서 다른 번역단위의 정적객체 tfs를 사용합니다.
문제는 tfs가 초기화가 된 상태인지 아닌지를 알 수 없다는 것입니다.
만일 초기화되지 않은 상태라면 런타임오류를 내고 프로그램이 죽을 가능 성이 높습니다.

이러한 문제를 우회하는 방법이 있는데, **비지역 정적객체를 지역 정적객체로** 바꾸는 것입니다.

```c++
//내가 만든 라이브러리의 코드
FileSystem& tfs(){
  static FileSystem fs; //이제는 지역 정적객체
  return fs;
}
```

```c++
void foo(){
  std::size_t disks - tfs().numDisks(); //다른 번역단위의 지역 정적객체를 사용!
}
```

전역으로 선언된 비지역 정적객체를, 전역 함수 안으로 옮겨넣음으로써 지역 정적객체로 바꿨습니다.
**지역 정적객체는 해당 함수가 호출되는 순간 초기화** 되므로, 해당 객체를 사용하기 전에 무조건 초기화된다는 사실이 보장됩니다.
이는 디자인 패턴의 싱클턴에서 주로 사용되는 기법으로 잘 알아두는 것이 좋습니다.

## 정리

- 복잡한 초기화 규칙을 외우고 선택적으로 초기화 하는 것 보다는, 항상 직접 초기화는 것이 속편합니다.
- 클래스의 멤버를 초기화할 때는 초기화리스트를 무조건적으로 사용합시다.
- 비지역 정적객체보다는 지역정적객체를 사용합시다.
