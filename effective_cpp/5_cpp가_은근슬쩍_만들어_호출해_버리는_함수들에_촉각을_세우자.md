# 5 : C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

---
## 문제인식
컴파일러는 클래스안에 다음과 같은 생성자가 없다면 자동으로 만들어 버립니다.

- 기본 생성자
- 복사 생성자
- 소멸자
- 복사 대입 연산자

내가 만들지 않았다고 해서 실행되지 않는 것도 아니고, 자동으로 만들어졌다고 해서 기대한대로 작동하는 것은 더더욱 아닙니다.
이렇게 자동으로 생기는 함수들을 어느 때 신경써야 할지 알아봅니다.

## 문제해결

### 기본 생성자
클래스에 생성자가 아무것도 없을 때 생성됩니다.
만일 파리미터를 받는 생성자를 사용자가 만들어 뒀다면 컴파일러는 기본 생성자를 자동으로 만들지 않습니다.<br>
자동으로 만들어진 기본 생성자는 멤버변수를 초기화 하는데, 항목 3에서 다룬 올바른 초기화를 기대하기 어렵습니다.
쓸모없는 기본 생성자가 자동으로 만들어지기 원하지 않는다면, 아래 두 가지 방법을 이용하면 됩니다.

- 파리미터를 받는 다른 생성자를 작성합니다.
- 정의가 없는 기본 생성자를 private 영역에 선언합니다.

### 복사 생성자
복사 생성자는 파리미터를 통해 넘어온 객체를 복사합니다.
클래스의 멤버변수 모두가 올바른 복사 생성자를 가지고 있다면, 자동으로 만들어진 복사 생성자는 올바르게 작동합니다.
문제는 아래와 같은 상황에서 발생하는데,

- 특정 멤버변수가 올바른 복사 생성자를 가지고 있지 않은 경우
- 특정 멤버변수가 상수객체인 경우

다행히 컴파일러가 복사 생성자 호출을 거부해버립니다.
정상적으로 컴파일하기 위해서는 해당 멤버변수를 일일이 복사하도록, 상수객체는 복사하지 않도록 복사 생성자를 작성해주면 됩니다.

### 소멸자
소멸자는 해당 인스턴스가 할당해서 사용한 자원들을 해제해주는 역할을 합니다.
따라서 반드시 직접 작성하는 것이 좋습니다.
한가지 더 기억해야 할 점은 클래스가 상속되는 경우인데, 상속될 수 있는 여지가 있는 클래스는 반드시 **가상 소멸자** 를 가져야만 합니다.(항목 7 참조)

### 복사 대입 연산자
복사 대입 연산자는 복사 생성자와 유사한 역할을 합니다.
대입 하는 객체의 값을 복사하기 해당 객체로 때문인데, 마찬가지로 상수객체를 복사하려는 시도가 일어나기 때문에 주의해야 합니다.

---
## 정리
- 기본 생성자, 복사 생성자, 소멸자, 복사 대입 연산자는 자동으로 만들어질 수 있습니다.
- 자동으로 만들어진 함수는 항상 기대한 동작을 한다고 보기 어렵습니다.
