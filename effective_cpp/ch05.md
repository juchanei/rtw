# 5 : C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

## 문제인식

컴파일러는 클래스안에 다음과 같은 생성자가 없다면 자동으로 만들어 버립니다.

- 기본 생성자
- 복사 생성자
- 소멸자
- 복사 대입 연산자

내가 만들지 않았다고 해서 실행되지 않는 것도 아니고, 자동으로 만들어졌다고 해서 기대한대로 작동하는 것은 더더욱 아닙니다.
이렇게 자동으로 생기는 함수들을 어느 때 신경써야 할지 알아봅니다.

## 문제해결

### 기본 생성자

클래스에 생성자가 아무것도 없을 때 생성됩니다.
만일 파리미터를 받는 생성자를 사용자가 만들어 뒀다면 컴파일러는 기본 생성자를 자동으로 만들지 않습니다.

자동으로 만들어진 기본 생성자는 멤버변수를 초기화 하는데, 항목 3에서 다룬 올바른 초기화를 기대하기 어렵습니다.
쓸모없는 기본 생성자가 자동으로 만들어지기 원하지 않는다면, 아래 두 가지 방법을 이용하면 됩니다.

- 파리미터를 받는 다른 생성자를 작성합니다.
- 정의가 없는 기본 생성자를 private 영역에 선언합니다.

### 복사 생성자

복사 생성자는 파리미터를 통해 넘어온 객체를 복사합니다.
클래스의 멤버변수 모두가 올바른 복사 생성자를 가지고 있다면, 자동으로 만들어진 복사 생성자는 올바르게 작동합니다.
문제는 아래와 같은 상황에서 발생하는데,

- 특정 멤버변수가 올바른 복사 생성자를 가지고 있지 않은 경우
- 특정 멤버변수가 상수객체인 경우

다행히 컴파일러가 복사 생성자 호출을 거부해버립니다.
정상적으로 컴파일하기 위해서는 해당 멤버변수를 일일이 복사하도록, 상수객체는 복사하지 않도록 복사 생성자를 작성해주면 됩니다.

### 소멸자

소멸자는 해당 인스턴스가 할당해서 사용한 자원들을 해제해주는 역할을 합니다.
따라서 반드시 직접 작성하는 것이 좋습니다.
한가지 더 기억해야 할 점은 클래스가 상속되는 경우인데, 상속될 수 있는 여지가 있는 클래스는 반드시 **가상 소멸자** 를 가져야만 합니다.[항목 7 참조](ch07.md)

### 복사 대입 연산자

복사 대입 연산자는 복사 생성자와 유사한 역할을 합니다.
대입 하는 객체의 값을 복사하기 해당 객체로 때문인데, 마찬가지로 상수객체를 복사하려는 시도가 일어나기 때문에 주의해야 합니다.

## 정리

- 기본 생성자, 복사 생성자, 소멸자, 복사 대입 연산자는 자동으로 만들어질 수 있습니다.
- 자동으로 만들어진 함수는 항상 기대한 동작을 한다고 보기 어렵습니다.
